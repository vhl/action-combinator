/**
 * @typedef {import('interfaces').Action} Action
 */

/**
 * @typedef {import('interfaces').Predicate} Predicate
 */

/** Create an action that chooses one of two actions to run, depending on
 * a predicate applied to the seed value.
 *
 * @param {Predicate} predicate  A function that returns either true or
 *                              false.
 * @param {Action}   consequent An action that will run if the predicate
 *                              returns true.
 * @param {Action}   alternate  An action that will run if the predicate
 *                              returns false.
 *
 * @return {Action}            An action.
 */
function branch(predicate, consequent, alternate) {
  return (resolve) => {
    const actionToExecute = predicate() ? consequent : alternate;
    actionToExecute(resolve);
  };
}

/** Resolve immediately. Can be used to cut out a branch early, for
 * example.
 *
 * @param {Function} resolve - The `resolve` callback from a Promise object.
 */
function doNothing(resolve) {
  resolve();
}

/**
 * It negates the result that is returned by the predicate.
 *
 * @param {Predicate} predicate - Function that its result is negated.
 * @param {...any} args - Arguments to be passed to the predicate.
 *
 * @return {Predicate}           - Result negated of predicate.
 */
function negate(predicate, ...args) {
  return () => {
    return !predicate(...args);
  };
}

/** Create an action that repeats the provided action while
 * the predicate is true.
 *
 * @param {Predicate} predicate A function that returns true or false.
 *
 * @param {Action} action      The action to be repeated.
 *
 * @return {Action}            An action.
 *                             The action runs the provided action while
 *                             predicate() is true.
 */
function repeatWhile(predicate, action) {
  // We need to return a function that might resolve, so we wrap the function
  // logic with a new arrow function that receives a resolve argument.
  return (resolve) => {
    // This is the recursive function that handles the stop.
    let maybeResolve = () => {
      if (predicate()) {
        action(maybeResolve); // Recursive joy.
      } else {
        resolve(); // Stop everything and resolve promise generated by actionToPromise.
      }
    };

    action(maybeResolve); // Let's enjoy recursive!
  };
}

/** Create an action that repeats the provided action until
 * the predicate is true.
 *
 * @param {Predicate} predicate A function that returns true or false.
 *
 * @param {Action} action      The action to be repeated.
 *
 * @return {Action}            An action.
 *                             The action runs the provided action until
 *                             predicate() is true.
 */
function repeatUntil(predicate, action) {
  return repeatWhile(negate(predicate), action);
}

/** Run an action when the predicate is false. When the predicate is true,
 * it does nothing.
 * It's the opposite of the when method.
 *
 * @param {Predicate} predicate  A function that returns true or false.
 *
 * @param {Action} action       The action to be run.
 *
 * @return {Action}            An action.
 */
function unless(predicate, action) {
  return branch(predicate, doNothing, action);
}

/** Run an action depending on the value of the predicate. When the
 * predicate is true, run the action.  When the predicate is false do nothing.
 *
 * It is a composition of branch() and doNothing().
 *
 * @param {Predicate} predicate  A function that returns true or false.
 *
 * @param {Action} action       The action to be run.
 *
 * @return {Action}            An action.
 */
function when(predicate, action) {
  return branch(predicate, action, doNothing);
}

export {
  branch,
  repeatWhile,
  repeatUntil,
  unless,
  when,
};
